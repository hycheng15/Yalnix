# COMP521-Lab2 The Yalnix Operating System Kernel

## 1 Team Members
*  Hua-Yu Cheng (hc105)
*  Cho-Yun Lei (cl227)

## 2 Repository Structure

* `pcb.h`: header file to define all the global variables, functions, and struct definitions
* `pcb.c`: implements functions that are related to process scheduling
* `globals.c`: initializes certain global variables and data structures
* `yalnix.c`: implements KernelStart (and functions used in KernelStart), and context switch functions
* `load.c`: loads the specified program
* `memory.c`: implements functions related to memory management
* `syscall.c`: implements Yalnix system calls
* `trap_handler.c`: implements Yalnix trap handlers
* `/tests`: contains all the test cases we pass, will be specified in section 3.2

## 3 Running and Testing

### 3.1 Running

One can simply run the following command to make and run the kernel.  
Our init program allocates and print a large array, forks a child and load second, and print some message.  
Usage:
```
make clean && make all
./yalnix -lk 1 -lu 1 -n init
```

### 3.2 Testing

We used some test cases provided and wrote our test cases in `/tests`  
Also, we are able to run the `tests/init` test inside the folder, execute and pass all the testcases by running the program inside the shell/console generated by `tests/init`  
Usage:  
```
./yalnix -lk 1 -lu 1 tests/init
```

## 4 Implementation Overview

 This section outlines the implementation details and features for the Yalnix kernel project, with a focus on process management, memory management, terminal I/O, and scheduling.

## 4.1 Memory Management

1. SetBrk  
    This function dynamically adjusts the heap boundary, managing physical page allocation or deallocation as needed. Corresponding updates are made to the page table, maintaining the crucial guard page between heap and stack.

2. ExpandStack  
    Pages are dynamically allocated when stack-related memory exceptions occur, ensuring stack operations continue uninterrupted.

3. DeletePageTable  
    Upon process termination, associated memory is freed (excluding the kernel stack for PID 0), clearing the page table and releasing associated physical pages.

4. SetKernelBrk  
    The kernel's heap boundary is initialized during system startup, carefully preventing overlaps with other memory regions. `KernelStart` internally invokes this function.

## 4.2 Kernel Initialization

1. KernelStart  
    Kernel initialization involves setting up the environment, including memory management, process queues, and hardware components. PID 0 is designated as the idle process, and its PCB is initialized. The kernel heap boundary is set via `SetKernelBrk`. The first user program is loaded using `LoadProgram` from `argv[1]`. Additionally, a trap vector table is configured to manage exceptions, system calls, and interrupts.

## 4.3 Interrupt, Exception, and Trap Handling

* Implements a unified trap handler to manage exceptions, system calls, and interrupts.
* Dispatches traps based on the trap type:
    * **System Calls**: Calls the appropriate kernel function (e.g., `KernelFork`, `KernelExec`).
    * **Memory Exceptions**: Handles page faults by expanding the stack or terminating the process.
    * **Clock Interrupts**: Decrements `delay_ticks` for delayed processes and unblocks them when the delay is complete.
    * **Terminal Interrupts**: Handles terminal read/write operations and unblocks processes waiting on terminal queues.
* Ensures that the kernel remains responsive to hardware events while managing processes.

### 4.3.1 Traps (System Calls)

1. KernelFork - implements the `Fork()` system call  
    To create a child process, we first verifying sufficient free physical pages and copy the parent's memory to the child, while a new PCB is allocated and initialized using `CreateNewProcess`. The parent's `childQ` is then updated, and the count of child processes (`children_num`) incremented. A context switch is performed using `ContextSwitch(forkSwitch)`, returning appropriate PIDs to the parent and child.

2. KernelExec - implements the `Exec()` system call  
    The current process's memory space is replaced using `LoadProgram`. Error handling is critical: recoverable errors (indicated by `-1`) simply return an `ERROR`, while unrecoverable errors (indicated by `-2`) trigger process termination via `KernelExit`.

3. KernelExit - implements the `Exit()` system call  
    When a process exits, it is marked as `TERMINATED`, and its exit status is stored. The kernel halts immediately if the idle process (PID 0) attempts to exit. The parent's `exitQ` is updated, unblocking it if it's waiting for the child. Any remaining child processes are designated as orphans. Finally, control switches to the next ready process using `ContextSwitch(exitSwitch)`.

4. KernelWait - implements the `Wait()` system call  
    Parents use `KernelWait` to await child process termination. If no child has exited yet, the parent is blocked until a child terminates. Upon child termination, the exit status is retrieved from `exitQ`, and the parent's child count is decremented.

5. KernelGetPid - implements the `GetPid()` system call  
    Returns current running process' PID

6. KernelBrk - implements the `Brk()` system call  
    User heap size modification is handled through `SetBrk`, carefully ensuring the heap does not overlap the stack, maintaining a guard page to prevent collisions

7. KernelDelay - implements the `Delay()` system call  
    Processes can be delayed for specific clock ticks using `KernelDelay`, which sets `delay_ticks` and triggers a context switch. Processes resume execution after the delay period ends.

8. KernelTtyRead - implements the `TtyRead()` system call  
    Terminal input is read into a buffer; if data is already available (`firstReceivedLine`), it is immediately copied. Otherwise, the reading process is blocked on `tty_read_blocked_queue` until data becomes available.

9. KernelTTyWrite - implements the `TTyWrite()` system call  
    Output data is written to terminal buffers; if terminals are busy, processes are blocked on `tty_write_blocked_queue` until terminals are free. Transmission is completed through `TtyTransmit` once terminals become available.

### 4.3.2 Interrupt (Hardware)

1. TrapClock  
    Clock interrupts are managed by decrementing `delay_ticks` for delayed processes, unblocking them upon completion, and enabling round-robin scheduling via context switching.

2. TrapTtyReceive  
    Terminal input interrupts are handled by transferring received data to terminal buffers and unblocking processes waiting on `tty_read_blocked_queue`.

3. TrapTtyTransmit  
    Terminal output interrupts mark terminals as available, unblocking processes queued in `tty_write_blocked_queue`.

4. TrapKernel  
    Handles **system calls** by dispatching to the appropriate kernel function (e.g., `KernelFork`, `KernelExec`). Uses the `ExceptionInfo` structure to pass arguments and return values between user and kernel space.

### 4.3.3 Exception (Errors)

1. TrapIllegal  
    Handles illegal instruction exceptions. When the CPU encounters an invalid or undefined instruction in user space, this trap is triggered. The kernel logs the excepction using TracePrintf, prints the error message, then terminates the process using `KernelExit(ERROR)`.
2. TrapMemory  
    Triggered when a user process accesses an unmapped or invalid memory address. If the faulting address is within the processâ€™s stack region and just below the current stack pointer, the kernel attempts to dynamically allocate and map a new stack page via `ExpandStack`. If the access is not part of a valid stack expansion (e.g., accessing unallocated heap or text), the process prints the error message and is terminated using `KernelExit(ERROR)` to prevent undefined behavior.
3. TrapMath  
    Occurs when a process performs an illegal arithmetic operation, such as division by zero or an invalid floating-point operation. Upon catching this exception, the kernel prints the error and immediately terminates the process with KernelExit(ERROR).

## 4.4 Program Loading

1. LoadProgram  
    Executable programs are loaded into memory by first parsing their headers to identify `text`, `data`, and `BSS` segments. Physical pages are allocated, mapped to the process's page table, and program contents are copied into memory. The initial stack setup includes arguments and environment variables. The function returns 0 for success, -1 for recoverable errors, and -2 for unrecoverable errors.